/*
Hudu API Documentation

<h1>Welcome to the Hudu REST API</h1> <p>The Hudu REST API enables seamless automation of your IT documentation. It's organized into various resources, each with its own specific endpoint.</p>  <h2>Authentication</h2> <p>All API requests require authentication using an API key. To obtain a key, go to <strong>Hudu Admin → Basic Information → API Keys</strong>.</p> <p>Include your API key in the request header, like so:</p> <pre><code>curl https://[YOUR_DOMAIN]/api/v1/companies?page=1 \\   -H \"x-api-key: YOUR_API_KEY_HERE\"</code></pre> <p>You can create and delete API keys at any time.</p>  <h2>Scoping API Keys</h2> <p>When creating an API key, you can configure the following permissions:</p> <ul>   <li>Access to passwords (all REST actions)</li>   <li>Destructive actions (DELETE)</li>   <li>Export capabilities</li>   <li>Whitelisted IPs</li>   <li>Company-specific access</li> </ul> <p>We recommend only granting the minimum required access for each application.</p>  <h2>Format</h2> <p>All API requests must use <strong>JSON</strong> format unless otherwise specified.</p>  <h2>Terminology</h2> <p>Some names in the API differ from those in the Hudu UI:</p> <table>   <thead>     <tr>       <th>Name in Hudu</th>       <th>Name in API</th>     </tr>   </thead>   <tbody>     <tr>       <td>Company (customizable)</td>       <td>Company</td>     </tr>     <tr>       <td>Password</td>       <td>AssetPassword</td>     </tr>     <tr>       <td>Knowledge Base Article</td>       <td>Article</td>     </tr>     <tr>       <td>Process</td>       <td>Procedure</td>     </tr>   </tbody> </table>  <h2>Pagination</h2> <p>All responses are paginated with 25 results per page. Use the <code>?page=X</code> query parameter to navigate.</p>  <h2>Rate Limiting</h2> <p>The API supports up to <strong>300 requests per minute</strong>.</p>  <p>&copy; 2023 Hudu Technologies, Inc. All rights reserved.</p>

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package huduapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// PublicPhotosAPIService PublicPhotosAPI service
type PublicPhotosAPIService service

type ApiCreatePublicPhotoRequest struct {
	ctx        context.Context
	ApiService *PublicPhotosAPIService
	photo      *os.File
	recordType *string
	recordId   *int32
}

// The photo file to be uploaded (must be an image).
func (r ApiCreatePublicPhotoRequest) Photo(photo *os.File) ApiCreatePublicPhotoRequest {
	r.photo = photo
	return r
}

// The type of record the photo will be associated with (e.g., Article).
func (r ApiCreatePublicPhotoRequest) RecordType(recordType string) ApiCreatePublicPhotoRequest {
	r.recordType = &recordType
	return r
}

// The ID of the record the photo will be associated with.
func (r ApiCreatePublicPhotoRequest) RecordId(recordId int32) ApiCreatePublicPhotoRequest {
	r.recordId = &recordId
	return r
}

func (r ApiCreatePublicPhotoRequest) Execute() (*PublicPhoto, *http.Response, error) {
	return r.ApiService.CreatePublicPhotoExecute(r)
}

/*
CreatePublicPhoto Create a public photo

Upload a public photo and associate it with a specific record type and ID. This will not upload the photo to the photos module or sidebar of the associated record (Upcoming Feature). This endpoint exists to add photos to articles and asset notes. **Note**: Response includes slug-based ID for improved security.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreatePublicPhotoRequest
*/
func (a *PublicPhotosAPIService) CreatePublicPhoto(ctx context.Context) ApiCreatePublicPhotoRequest {
	return ApiCreatePublicPhotoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PublicPhoto
func (a *PublicPhotosAPIService) CreatePublicPhotoExecute(r ApiCreatePublicPhotoRequest) (*PublicPhoto, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PublicPhoto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicPhotosAPIService.CreatePublicPhoto")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public_photos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.photo == nil {
		return localVarReturnValue, nil, reportError("photo is required and must be specified")
	}
	if r.recordType == nil {
		return localVarReturnValue, nil, reportError("recordType is required and must be specified")
	}
	if r.recordId == nil {
		return localVarReturnValue, nil, reportError("recordId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var photoLocalVarFormFileName string
	var photoLocalVarFileName string
	var photoLocalVarFileBytes []byte

	photoLocalVarFormFileName = "photo"
	photoLocalVarFile := r.photo

	if photoLocalVarFile != nil {
		fbs, _ := io.ReadAll(photoLocalVarFile)

		photoLocalVarFileBytes = fbs
		photoLocalVarFileName = photoLocalVarFile.Name()
		photoLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: photoLocalVarFileBytes, fileName: photoLocalVarFileName, formFileName: photoLocalVarFormFileName})
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "record_type", r.recordType, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "record_id", r.recordId, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicPhotosRequest struct {
	ctx        context.Context
	ApiService *PublicPhotosAPIService
	page       *int32
	pageSize   *int32
}

// The current page of results.
func (r ApiGetPublicPhotosRequest) Page(page int32) ApiGetPublicPhotosRequest {
	r.page = &page
	return r
}

// The number of results to return per page.
func (r ApiGetPublicPhotosRequest) PageSize(pageSize int32) ApiGetPublicPhotosRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetPublicPhotosRequest) Execute() (*GetPublicPhotos200Response, *http.Response, error) {
	return r.ApiService.GetPublicPhotosExecute(r)
}

/*
GetPublicPhotos Get a list of public photos

Retrieve a list of public photos with pagination options. **Note**: Response now includes slug-based IDs for improved security. See PublicPhoto definition for details on the new `id` and `numeric_id` fields.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetPublicPhotosRequest
*/
func (a *PublicPhotosAPIService) GetPublicPhotos(ctx context.Context) ApiGetPublicPhotosRequest {
	return ApiGetPublicPhotosRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetPublicPhotos200Response
func (a *PublicPhotosAPIService) GetPublicPhotosExecute(r ApiGetPublicPhotosRequest) (*GetPublicPhotos200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetPublicPhotos200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicPhotosAPIService.GetPublicPhotos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public_photos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePublicPhotoRequest struct {
	ctx        context.Context
	ApiService *PublicPhotosAPIService
	id         int32
	recordType *string
	recordId   *int32
}

// The updated type of record the photo is associated with (e.g., Article).
func (r ApiUpdatePublicPhotoRequest) RecordType(recordType string) ApiUpdatePublicPhotoRequest {
	r.recordType = &recordType
	return r
}

// The updated ID of the record the photo is associated with.
func (r ApiUpdatePublicPhotoRequest) RecordId(recordId int32) ApiUpdatePublicPhotoRequest {
	r.recordId = &recordId
	return r
}

func (r ApiUpdatePublicPhotoRequest) Execute() (*UpdatePublicPhoto200Response, *http.Response, error) {
	return r.ApiService.UpdatePublicPhotoExecute(r)
}

/*
UpdatePublicPhoto Update a public photo

Update the associated record type and ID for a specific public photo. **Backward Compatibility**: This endpoint still accepts numeric IDs in the path parameter for existing integrations, but responses will include the new slug-based ID format.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The numeric ID of the public photo to update. **Backward Compatibility**: This endpoint continues to accept numeric IDs for existing integrations.
	@return ApiUpdatePublicPhotoRequest
*/
func (a *PublicPhotosAPIService) UpdatePublicPhoto(ctx context.Context, id int32) ApiUpdatePublicPhotoRequest {
	return ApiUpdatePublicPhotoRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return UpdatePublicPhoto200Response
func (a *PublicPhotosAPIService) UpdatePublicPhotoExecute(r ApiUpdatePublicPhotoRequest) (*UpdatePublicPhoto200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpdatePublicPhoto200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicPhotosAPIService.UpdatePublicPhoto")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public_photos/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.recordType == nil {
		return localVarReturnValue, nil, reportError("recordType is required and must be specified")
	}
	if r.recordId == nil {
		return localVarReturnValue, nil, reportError("recordId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "record_type", r.recordType, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "record_id", r.recordId, "", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
