/*
Hudu API Documentation

<h1>Welcome to the Hudu REST API</h1> <p>The Hudu REST API enables seamless automation of your IT documentation. It's organized into various resources, each with its own specific endpoint.</p>  <h2>Authentication</h2> <p>All API requests require authentication using an API key. To obtain a key, go to <strong>Hudu Admin → Basic Information → API Keys</strong>.</p> <p>Include your API key in the request header, like so:</p> <pre><code>curl https://[YOUR_DOMAIN]/api/v1/companies?page=1 \\   -H \"x-api-key: YOUR_API_KEY_HERE\"</code></pre> <p>You can create and delete API keys at any time.</p>  <h2>Scoping API Keys</h2> <p>When creating an API key, you can configure the following permissions:</p> <ul>   <li>Access to passwords (all REST actions)</li>   <li>Destructive actions (DELETE)</li>   <li>Export capabilities</li>   <li>Whitelisted IPs</li>   <li>Company-specific access</li> </ul> <p>We recommend only granting the minimum required access for each application.</p>  <h2>Format</h2> <p>All API requests must use <strong>JSON</strong> format unless otherwise specified.</p>  <h2>Terminology</h2> <p>Some names in the API differ from those in the Hudu UI:</p> <table>   <thead>     <tr>       <th>Name in Hudu</th>       <th>Name in API</th>     </tr>   </thead>   <tbody>     <tr>       <td>Company (customizable)</td>       <td>Company</td>     </tr>     <tr>       <td>Password</td>       <td>AssetPassword</td>     </tr>     <tr>       <td>Knowledge Base Article</td>       <td>Article</td>     </tr>     <tr>       <td>Process</td>       <td>Procedure</td>     </tr>   </tbody> </table>  <h2>Pagination</h2> <p>All responses are paginated with 25 results per page. Use the <code>?page=X</code> query parameter to navigate.</p>  <h2>Rate Limiting</h2> <p>The API supports up to <strong>300 requests per minute</strong>.</p>  <p>&copy; 2023 Hudu Technologies, Inc. All rights reserved.</p>

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package huduapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// AssetsAPIService AssetsAPI service
type AssetsAPIService service

type ApiDeleteCompaniesCompanyIdAssetsIdRequest struct {
	ctx        context.Context
	ApiService *AssetsAPIService
	id         float32
	companyId  float32
}

func (r ApiDeleteCompaniesCompanyIdAssetsIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCompaniesCompanyIdAssetsIdExecute(r)
}

/*
DeleteCompaniesCompanyIdAssetsId Delete an Asset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The identifier of the requested Asset
	@param companyId The identifier of the requested parent Company
	@return ApiDeleteCompaniesCompanyIdAssetsIdRequest
*/
func (a *AssetsAPIService) DeleteCompaniesCompanyIdAssetsId(ctx context.Context, id float32, companyId float32) ApiDeleteCompaniesCompanyIdAssetsIdRequest {
	return ApiDeleteCompaniesCompanyIdAssetsIdRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		companyId:  companyId,
	}
}

// Execute executes the request
func (a *AssetsAPIService) DeleteCompaniesCompanyIdAssetsIdExecute(r ApiDeleteCompaniesCompanyIdAssetsIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsAPIService.DeleteCompaniesCompanyIdAssetsId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/companies/{company_id}/assets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAssetsRequest struct {
	ctx           context.Context
	ApiService    *AssetsAPIService
	companyId     *float32
	id            *float32
	name          *string
	primarySerial *string
	assetLayoutId *float32
	page          *float32
	archived      *bool
	pageSize      *float32
	slug          *string
	search        *string
	updatedAt     *string
}

// Filter assets by the parent company&#39;s ID
func (r ApiGetAssetsRequest) CompanyId(companyId float32) ApiGetAssetsRequest {
	r.companyId = &companyId
	return r
}

// Filter assets by their ID
func (r ApiGetAssetsRequest) Id(id float32) ApiGetAssetsRequest {
	r.id = &id
	return r
}

// Filter assets by their name
func (r ApiGetAssetsRequest) Name(name string) ApiGetAssetsRequest {
	r.name = &name
	return r
}

// Filter assets by their primary serial number
func (r ApiGetAssetsRequest) PrimarySerial(primarySerial string) ApiGetAssetsRequest {
	r.primarySerial = &primarySerial
	return r
}

// Filter assets by their associated asset layout&#39;s ID
func (r ApiGetAssetsRequest) AssetLayoutId(assetLayoutId float32) ApiGetAssetsRequest {
	r.assetLayoutId = &assetLayoutId
	return r
}

// Specify the page number of results to return
func (r ApiGetAssetsRequest) Page(page float32) ApiGetAssetsRequest {
	r.page = &page
	return r
}

// Set to true to display only archived assets
func (r ApiGetAssetsRequest) Archived(archived bool) ApiGetAssetsRequest {
	r.archived = &archived
	return r
}

// Limit the number of assets returned per page
func (r ApiGetAssetsRequest) PageSize(pageSize float32) ApiGetAssetsRequest {
	r.pageSize = &pageSize
	return r
}

// Filter assets by their URL slug
func (r ApiGetAssetsRequest) Slug(slug string) ApiGetAssetsRequest {
	r.slug = &slug
	return r
}

// Filter assets using a search query
func (r ApiGetAssetsRequest) Search(search string) ApiGetAssetsRequest {
	r.search = &search
	return r
}

// Filter assets updated within a range or at an exact time. Format: &#39;start_datetime,end_datetime&#39; for range, &#39;exact_datetime&#39; for exact match.
func (r ApiGetAssetsRequest) UpdatedAt(updatedAt string) ApiGetAssetsRequest {
	r.updatedAt = &updatedAt
	return r
}

func (r ApiGetAssetsRequest) Execute() (*GetAssets200Response, *http.Response, error) {
	return r.ApiService.GetAssetsExecute(r)
}

/*
GetAssets Retrieve a list of assets

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAssetsRequest
*/
func (a *AssetsAPIService) GetAssets(ctx context.Context) ApiGetAssetsRequest {
	return ApiGetAssetsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetAssets200Response
func (a *AssetsAPIService) GetAssetsExecute(r ApiGetAssetsRequest) (*GetAssets200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAssets200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsAPIService.GetAssets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.companyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "company_id", r.companyId, "", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "", "")
	}
	if r.primarySerial != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "primary_serial", r.primarySerial, "", "")
	}
	if r.assetLayoutId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asset_layout_id", r.assetLayoutId, "", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "", "")
	}
	if r.slug != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "slug", r.slug, "", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "", "")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at", r.updatedAt, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCompaniesCompanyIdAssetsRequest struct {
	ctx        context.Context
	ApiService *AssetsAPIService
	companyId  float32
	page       *float32
	archived   *bool
	pageSize   *float32
}

// The current page of results to retrieve
func (r ApiGetCompaniesCompanyIdAssetsRequest) Page(page float32) ApiGetCompaniesCompanyIdAssetsRequest {
	r.page = &page
	return r
}

// Set to true to only show archived results
func (r ApiGetCompaniesCompanyIdAssetsRequest) Archived(archived bool) ApiGetCompaniesCompanyIdAssetsRequest {
	r.archived = &archived
	return r
}

// The number of results to return per page
func (r ApiGetCompaniesCompanyIdAssetsRequest) PageSize(pageSize float32) ApiGetCompaniesCompanyIdAssetsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetCompaniesCompanyIdAssetsRequest) Execute() (*GetAssets200Response, *http.Response, error) {
	return r.ApiService.GetCompaniesCompanyIdAssetsExecute(r)
}

/*
GetCompaniesCompanyIdAssets Get a list of Assets specific to a Company

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param companyId The identifier of the requested parent Company
	@return ApiGetCompaniesCompanyIdAssetsRequest
*/
func (a *AssetsAPIService) GetCompaniesCompanyIdAssets(ctx context.Context, companyId float32) ApiGetCompaniesCompanyIdAssetsRequest {
	return ApiGetCompaniesCompanyIdAssetsRequest{
		ApiService: a,
		ctx:        ctx,
		companyId:  companyId,
	}
}

// Execute executes the request
//
//	@return GetAssets200Response
func (a *AssetsAPIService) GetCompaniesCompanyIdAssetsExecute(r ApiGetCompaniesCompanyIdAssetsRequest) (*GetAssets200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAssets200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsAPIService.GetCompaniesCompanyIdAssets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/companies/{company_id}/assets"
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCompaniesCompanyIdAssetsIdRequest struct {
	ctx        context.Context
	ApiService *AssetsAPIService
	id         float32
	companyId  float32
}

func (r ApiGetCompaniesCompanyIdAssetsIdRequest) Execute() (*Asset, *http.Response, error) {
	return r.ApiService.GetCompaniesCompanyIdAssetsIdExecute(r)
}

/*
GetCompaniesCompanyIdAssetsId Get an Asset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The identifier of the requested Asset
	@param companyId The identifier of the requested parent Company
	@return ApiGetCompaniesCompanyIdAssetsIdRequest
*/
func (a *AssetsAPIService) GetCompaniesCompanyIdAssetsId(ctx context.Context, id float32, companyId float32) ApiGetCompaniesCompanyIdAssetsIdRequest {
	return ApiGetCompaniesCompanyIdAssetsIdRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		companyId:  companyId,
	}
}

// Execute executes the request
//
//	@return Asset
func (a *AssetsAPIService) GetCompaniesCompanyIdAssetsIdExecute(r ApiGetCompaniesCompanyIdAssetsIdRequest) (*Asset, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Asset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsAPIService.GetCompaniesCompanyIdAssetsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/companies/{company_id}/assets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCompaniesCompanyIdAssetsRequest struct {
	ctx        context.Context
	ApiService *AssetsAPIService
	companyId  float32
	asset      *PostCompaniesCompanyIdAssetsRequest
}

// Create a new asset by sending asset data in the request body formatted as JSON.  **Important:** Use the &#x60;custom_fields&#x60; key to specify values for the asset&#39;s custom fields. Each custom field should be provided as a key-value pair, where the **key** must exactly match the name of the custom field you&#39;ve created in your Asset Layout (converted to snake case: lowercase letters and underscores in place of spaces).  Examples of custom field types and formats:  * **Text fields:** A simple string value.   * Example: &#x60;{ \&quot;your_custom_text_field\&quot;: \&quot;Some text here\&quot; }&#x60;  * **Date fields:** Date formatted as YYYY/MM/DD.   * Example: &#x60;{ \&quot;your_due_date\&quot;: \&quot;2024/01/15\&quot; }&#x60;  * **Checkbox fields:** Boolean as a string (\&quot;true\&quot; or \&quot;false\&quot;).   * Example: &#x60;{ \&quot;is_active\&quot;: \&quot;true\&quot; }&#x60;  * **Number fields:** Numeric value as a string.   * Example: &#x60;{ \&quot;your_score\&quot;: \&quot;5\&quot; }&#x60;  * **Address fields:** Object containing required address components.   * Example: &#x60;{ \&quot;office_location\&quot;: { \&quot;address_line_1\&quot;: \&quot;123 Main St\&quot;, \&quot;city\&quot;: \&quot;Denver\&quot;, \&quot;state\&quot;: \&quot;CO\&quot;, \&quot;zip\&quot;: \&quot;80202\&quot;, \&quot;country_name\&quot;: \&quot;USA\&quot; } }&#x60;  * **Asset tag fields:** Array of asset IDs.   * Example: &#x60;{ \&quot;your_linked_assets\&quot;: [456, 789] }&#x60;  * **List select fields:** Array of item names.   * Example: &#x60;{ \&quot;your_categories\&quot;: [\&quot;Item 1\&quot;, \&quot;Item 2\&quot;] }&#x60;  Replace placeholder keys (like &#x60;your_custom_text_field&#x60;) with the exact name of your Asset Layout&#39;s custom fields.
func (r ApiPostCompaniesCompanyIdAssetsRequest) Asset(asset PostCompaniesCompanyIdAssetsRequest) ApiPostCompaniesCompanyIdAssetsRequest {
	r.asset = &asset
	return r
}

func (r ApiPostCompaniesCompanyIdAssetsRequest) Execute() (*Asset, *http.Response, error) {
	return r.ApiService.PostCompaniesCompanyIdAssetsExecute(r)
}

/*
PostCompaniesCompanyIdAssets Create an Asset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param companyId The identifier of the parent company for the new asset
	@return ApiPostCompaniesCompanyIdAssetsRequest
*/
func (a *AssetsAPIService) PostCompaniesCompanyIdAssets(ctx context.Context, companyId float32) ApiPostCompaniesCompanyIdAssetsRequest {
	return ApiPostCompaniesCompanyIdAssetsRequest{
		ApiService: a,
		ctx:        ctx,
		companyId:  companyId,
	}
}

// Execute executes the request
//
//	@return Asset
func (a *AssetsAPIService) PostCompaniesCompanyIdAssetsExecute(r ApiPostCompaniesCompanyIdAssetsRequest) (*Asset, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Asset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsAPIService.PostCompaniesCompanyIdAssets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/companies/{company_id}/assets"
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.asset
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutCompaniesCompanyIdAssetsIdRequest struct {
	ctx        context.Context
	ApiService *AssetsAPIService
	id         float32
	companyId  float32
	asset      *map[string]interface{}
}

// Update an existing asset by sending asset data in the request body formatted as JSON.  **Important:** Use the &#x60;custom_fields&#x60; key to specify values for the asset&#39;s custom fields. Each custom field should be provided as a hash keyed by the field&#39;s label (case-insensitive, spaces or underscores allowed).  Examples of field types and formats:  * **Text fields:** &#x60;{ \&quot;your_custom_text_field_one\&quot;: \&quot;Some updated text\&quot; }&#x60; * **Date fields:** &#x60;{ \&quot;your_due_date\&quot;: \&quot;2025/02/15\&quot; }&#x60; * **Checkbox fields:** &#x60;{ \&quot;is_active\&quot;: true }&#x60; * **Number fields:** &#x60;{ \&quot;your_score\&quot;: 8 }&#x60; * **Asset tag fields:** &#x60;{ \&quot;your_linked_assets\&quot;: [123, 456] }&#x60; * **List select fields:** &#x60;{ \&quot;your_categories\&quot;: [\&quot;Item 2\&quot;, \&quot;Item 3\&quot;] }&#x60; * **Address fields:** &#x60;{ \&quot;office_location\&quot;: { \&quot;address_line_1\&quot;: \&quot;123 Test Street\&quot;, \&quot;address_line_2\&quot;: \&quot;Suite 1\&quot;, \&quot;city\&quot;: \&quot;Boulder\&quot;, \&quot;state\&quot;: \&quot;CO\&quot;, \&quot;zip\&quot;: \&quot;80301\&quot;, \&quot;country_name\&quot;: \&quot;US\&quot; } }&#x60;
func (r ApiPutCompaniesCompanyIdAssetsIdRequest) Asset(asset map[string]interface{}) ApiPutCompaniesCompanyIdAssetsIdRequest {
	r.asset = &asset
	return r
}

func (r ApiPutCompaniesCompanyIdAssetsIdRequest) Execute() (*Asset, *http.Response, error) {
	return r.ApiService.PutCompaniesCompanyIdAssetsIdExecute(r)
}

/*
PutCompaniesCompanyIdAssetsId Update an Asset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The identifier of the requested Asset
	@param companyId The identifier of the requested parent Company
	@return ApiPutCompaniesCompanyIdAssetsIdRequest
*/
func (a *AssetsAPIService) PutCompaniesCompanyIdAssetsId(ctx context.Context, id float32, companyId float32) ApiPutCompaniesCompanyIdAssetsIdRequest {
	return ApiPutCompaniesCompanyIdAssetsIdRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		companyId:  companyId,
	}
}

// Execute executes the request
//
//	@return Asset
func (a *AssetsAPIService) PutCompaniesCompanyIdAssetsIdExecute(r ApiPutCompaniesCompanyIdAssetsIdRequest) (*Asset, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Asset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsAPIService.PutCompaniesCompanyIdAssetsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/companies/{company_id}/assets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.asset
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutCompaniesCompanyIdAssetsIdArchiveRequest struct {
	ctx        context.Context
	ApiService *AssetsAPIService
	id         float32
	companyId  float32
}

func (r ApiPutCompaniesCompanyIdAssetsIdArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutCompaniesCompanyIdAssetsIdArchiveExecute(r)
}

/*
PutCompaniesCompanyIdAssetsIdArchive Archive an Asset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The identifier of the requested Asset
	@param companyId The identifier of the requested parent Company
	@return ApiPutCompaniesCompanyIdAssetsIdArchiveRequest
*/
func (a *AssetsAPIService) PutCompaniesCompanyIdAssetsIdArchive(ctx context.Context, id float32, companyId float32) ApiPutCompaniesCompanyIdAssetsIdArchiveRequest {
	return ApiPutCompaniesCompanyIdAssetsIdArchiveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		companyId:  companyId,
	}
}

// Execute executes the request
func (a *AssetsAPIService) PutCompaniesCompanyIdAssetsIdArchiveExecute(r ApiPutCompaniesCompanyIdAssetsIdArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsAPIService.PutCompaniesCompanyIdAssetsIdArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/companies/{company_id}/assets/{id}/archive"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutCompaniesCompanyIdAssetsIdMoveLayoutRequest struct {
	ctx        context.Context
	ApiService *AssetsAPIService
	companyId  int32
	id         int32
	body       *PutCompaniesCompanyIdAssetsIdMoveLayoutRequest
}

func (r ApiPutCompaniesCompanyIdAssetsIdMoveLayoutRequest) Body(body PutCompaniesCompanyIdAssetsIdMoveLayoutRequest) ApiPutCompaniesCompanyIdAssetsIdMoveLayoutRequest {
	r.body = &body
	return r
}

func (r ApiPutCompaniesCompanyIdAssetsIdMoveLayoutRequest) Execute() (*Asset, *http.Response, error) {
	return r.ApiService.PutCompaniesCompanyIdAssetsIdMoveLayoutExecute(r)
}

/*
PutCompaniesCompanyIdAssetsIdMoveLayout Move asset to a different layout

Moves an Asset to a new Layout while preserving field values. The system will:

1. Match existing fields between layouts by exact label and type (case-sensitive, spaces matter)
2. Create new fields in the target layout if they don't exist
3. Transfer all field values to their corresponding fields in the new layout
4. Validate that any required fields in the new layout exist in the current layout

Note: Fields are matched by their label and type. If a field with the same label (case-sensitive, spaces matter) and type exists in the target layout, the asset's field value will be mapped to that existing field. If no matching field exists, a new one will be created with the same properties as the source field.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param companyId ID of the parent company
	@param id ID of the asset to move
	@return ApiPutCompaniesCompanyIdAssetsIdMoveLayoutRequest
*/
func (a *AssetsAPIService) PutCompaniesCompanyIdAssetsIdMoveLayout(ctx context.Context, companyId int32, id int32) ApiPutCompaniesCompanyIdAssetsIdMoveLayoutRequest {
	return ApiPutCompaniesCompanyIdAssetsIdMoveLayoutRequest{
		ApiService: a,
		ctx:        ctx,
		companyId:  companyId,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Asset
func (a *AssetsAPIService) PutCompaniesCompanyIdAssetsIdMoveLayoutExecute(r ApiPutCompaniesCompanyIdAssetsIdMoveLayoutRequest) (*Asset, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Asset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsAPIService.PutCompaniesCompanyIdAssetsIdMoveLayout")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/companies/{company_id}/assets/{id}/move_layout"
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutCompaniesCompanyIdAssetsIdUnarchiveRequest struct {
	ctx        context.Context
	ApiService *AssetsAPIService
	id         float32
	companyId  float32
}

func (r ApiPutCompaniesCompanyIdAssetsIdUnarchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutCompaniesCompanyIdAssetsIdUnarchiveExecute(r)
}

/*
PutCompaniesCompanyIdAssetsIdUnarchive Unarchive an Asset

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The identifier of the requested Asset
	@param companyId The identifier of the requested parent Company
	@return ApiPutCompaniesCompanyIdAssetsIdUnarchiveRequest
*/
func (a *AssetsAPIService) PutCompaniesCompanyIdAssetsIdUnarchive(ctx context.Context, id float32, companyId float32) ApiPutCompaniesCompanyIdAssetsIdUnarchiveRequest {
	return ApiPutCompaniesCompanyIdAssetsIdUnarchiveRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
		companyId:  companyId,
	}
}

// Execute executes the request
func (a *AssetsAPIService) PutCompaniesCompanyIdAssetsIdUnarchiveExecute(r ApiPutCompaniesCompanyIdAssetsIdUnarchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsAPIService.PutCompaniesCompanyIdAssetsIdUnarchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/companies/{company_id}/assets/{id}/unarchive"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"company_id"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
